let _ = require('lodash'),
    getPositionsBetween = require('app/utils/getPositionsBetween'),
    rand = require('app/utils/rand'),
    config = require('app/config');

module.exports = (allStops) =>
  _
  .range(config.lines)
  .map(
    (item, index) => {
      let keyStops, positions, stops, dTimes, departures, latencies;

      keyStops = allStops.filter(
        () => rand.random() < config.keyStopProbability
      ),

      positions = _
        .tail(keyStops)
        .reduce(
          (prev, curr) =>
            prev.concat(
              getPositionsBetween(_.last(prev), curr.pos)
            ),
          [_.head(keyStops).pos]
        );

      stops = positions.reduce((prev, curr) => {
        let stop = allStops.find(
          stop =>
            stop.pos.x === curr.x &&
            stop.pos.y === curr.y
        );
        return stop ? prev.concat([stop]) : prev;
      }, []);

      dTimes = _
        .tail(stops)
        .reduce((prev, curr) => {
          return prev.concat([{
            stop: curr,

            // time difference between stops
            dTime: parseInt(
              ( // distance
              Math.abs(
                curr.pos.x - _.last(prev).stop.pos.x
              ) + Math.abs(
                curr.pos.y - _.last(prev).stop.pos.y
              )
            ) * config.kmPerGridCell / config.busAvgSpeed * 60 * 60
                + 15 // assumes that bus stays 15 seconds on given stop
            )
          }]);
        }, [{
          stop: _.head(stops),
          dTime: 0
        }])
        .map(item => item.dTime);

      departures = _
        .range(rand(config.maxStartsPerDay))
        .map(() => {
          return {
            hour: rand(24),
            minutes: rand(60),
            seconds: 0
          };
        }).sort(
          (a, b) =>
            a.hour - b.hour || a.minutes - b.minutes
        );

      latencies = departures.map(() => rand(config.maxInitialLatency));

    return {
      id: index,
      name: '' + (index + 100),
      positions: positions,
      stops: stops,
      dTimes: dTimes,
      departures: departures,
      latencies: latencies
    };
  });

